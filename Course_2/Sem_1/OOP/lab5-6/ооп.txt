1. Обычно система сама генерирует исключения при определенных ситуациях, например, при делении числа на ноль. 
Но язык C# также позволяет генерировать исключения вручную с помощью оператора throw. 
То есть с помощью этого оператора мы сами можем создать исключение и вызвать его в процессе выполнения.
После оператора throw указывается объект исключения, через конструктор которого мы можем передать сообщение об ошибке.
Естественно вместо типа Exception мы можем использовать объект любого другого типа исключений.
Затем в блоке catch сгенерированное нами исключение будет обработано.
Подобным образом мы можем генерировать исключения в любом месте программы. 
Но существует также и другая форма использования оператора throw, когда после данного оператора не указывается объект исключения. 
В подобном виде оператор throw может использоваться только в блоке catch:

2. Иногда при выполнении программы возникают ошибки, которые трудно предусмотреть или предвидеть,
 а иногда и вовсе невозможно. Например, при передачи файла по сети может неожиданно оборваться сетевое подключение. 
такие ситуации называются исключениями. Язык C# предоставляет разработчикам возможности для обработки таких ситуаций. 
Для этого в C# предназначена конструкция try...catch...finally.
При использовании блока try...catch..finally вначале выполняются все инструкции в блоке try. 
Если в этом блоке не возникло исключений, то после его выполнения начинает выполняться блок finally.
 И затем конструкция try..catch..finally завершает свою работу.
Если же в блоке try вдруг возникает исключение, то обычный порядок выполнения останавливается, 
и среда CLR начинает искать блок catch, который может обработать данное исключение. 
Если нужный блок catch найден, то он выполняется, и после его завершения выполняется блок finally.
Если нужный блок catch не найден, то при возникновении исключения программа аварийно завершает свое выполнение.

3. Ключевое слово try служит для обозначения контролируемого
блока ‒ кода, в котором может генерироваться исключение. Блок
заключается в фигурные скобки:

5. Если в программе нет предложения catch, способного обработать исключение, оно остается необработанным. 
Но исключение – это настолько серьезная ошибка, что программа не может продолжать выполнение. 

6. Фильтры исключений срабатывают, если при выполнении метода действия будет выброшено необработанное исключение.

С одной стороны, мы могли поместить всю логику выполнения метода в блок try...catch и отследить исключение. 
Однако область работы фильтров исключения несколько шире. Они позволяют отследить не только исключения, 
возникающие в самом методе, но исключения, генерируемые результатами действий, 
а также другими применяемыми к данному действию фильтрами. В этом и состоит мощь данного типа фильтров.
И если вдруг приложение выбрасывает необрабатываемое исключение, то фильтр вызывает метод OnException.

Все фильтры исключений должны применять интерфейс IExceptionFilter:

7.С одним оператором try можно связать несколько операторов catch. 
И на практике это делается довольно часто.
 Но все операторы catch должны перехватывать исключения разного типа:
Как следует из приведенного выше результата, каждый оператор catch реагирует только на свой тип исключения.

Вообще говоря, операторы catch выполняются по порядку их следования в программе. 
Но при этом выполняется только один блок catch, в котором тип исключения совпадает с типом генерируемого исключения.
 А все остальные блоки catch пропускаются
один блок try может быть вложен в другой. 
Исключение, генерируемое во внутреннем блоке try и не перехваченное в соответствующем блоке catch, 
передается во внешний блок try:

8. Блок catch, отлавливающий исключения типа System. Exception. 
Также можно просто использовать catch{}, не указывая тип исключения.

11. Если возникает необходимость снова сгенерировать исключения из блока, который обрабатывает исключения, можно сделать 
это путем вызова throw без указания исключения. 
В результате теку­щее исключение будет передано во внешнюю последовательность try/catch обработки исключений. 
Причиной для этого может послужить желание обрабатывать исключения несколькими обработ­чиками. 
Например, один обработчик может заниматься одним аспектом исключения, а второй обработчик — другим. 
Исключение может быть снова сгенерировано или изнутри блока catch, или из функции, вызванной в этом блоке. 
Когда повторно генерируется исключение, оно не бу­дет перехвачено той же самой инструкцией catch. 
Оно будет распространяться до следующей внешней инструкции catch. 
Следующая программа иллюстрирует повторную генерацию исключе­ния. В ней повторно генерируется исключение типа char*.

12. innerException: хранит информацию об исключении, которое послужило причиной текущего исключения

Message: хранит сообщение об исключении, текст ошибки

Source: хранит имя объекта или сборки, которое вызвало исключение

StackTrace: возвращает строковое представление стека вызывов, которые привели к возникновению исключения

TargetSite: возвращает метод, в котором и было вызвано исключение

DivideByZeroException: представляет исключение, которое генерируется при делении на ноль

ArgumentOutOfRangeException: генерируется, если значение аргумента находится вне диапазона допустимых значений

ArgumentException: генерируется, если в метод для параметра передается некорректное значение

IndexOutOfRangeException: генерируется, если индекс элемента массива или коллекции находится вне диапазона допустимых значений

InvalidCastException: генерируется при попытке произвести недопустимые преобразования типов

NullReferenceException: генерируется при попытке обращения к объекту, который равен null (то есть по сути неопределен)